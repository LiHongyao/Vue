# 一、概述

组件是带有名称的可复用实例， 是 Vue 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue 的编译器为它添加特殊功能。

通常一个应用会以一棵嵌套的组件树的形式来组织：

![](./IMGS/components.png)

例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。

为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：**全局注册** 和 **局部注册**。

# 二、 组件注册

## 1. 组件名

在字符串模板或单文件组件中定义组件时，定义组件名的方式有两种：

**@使用 kebab-case**

```javascript
app.component('my-component-name', {
  /* ... */
})
```

当使用 kebab-case (短横线分隔命名) 定义一个组件时，你在引用这个自定义元素时也必须使用 kebab-case

**@使用 PascalCase**

```javascript
app.component('MyComponentName', {
  /* ... */
})
```

当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。尽管如此，还是建议使用 kebab-case。

## 2. 全局注册

```js
// Create a Vue application
const app = Vue.createApp({})

// Define a new global component called button-counter
app.component('button-counter', {
  data() {
    return {
      count: 0
    }
  },
  template: `
    <button @click="count++">
      You clicked me {{ count }} times.
    </button>`
})
```

> 注意：`data` 必须是函数，且必须返回一个对象。

使用组件：

```vue
<div id="app">
  <button-counter />
  <button-counter />
  <button-counter />
</div>
```

## 3. 局部注册

```javascript
const ComponentA = {
  /* ... */
}

const ComponentB = {
  components: {
    'component-a': ComponentA
  }
  // ...
}
```

## 4. 模版字符串异常

在 Vue3 中，如果你使用 `template` 模板字符串定义组件，会抛出如下异常：

```
[Vue warn]: Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js". 
```

**异常解读**：组件提供了模板选项，但在此Vue构建中不支持运行时编译。 将你的 bundler 的别名 `vue` 配置为 `vue/dist/vue.esm-bundle .js`。  

**解决方案：**由于本教程主要基于 `Vite` 构建，所以这里主要讲解在 vite 中的处理方案。根据异常解读，不难发现，我们只需要配置 `vue` 别名即可。在 `vite.config.js` 文件中添加如下代码：

```javascript
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()],
  // +++
  resolve: {
    alias: {
      vue: 'vue/dist/vue.esm-bundler.js', 
    },
  },
  // +++
});
```

## 5. 单文件组件（推荐）

### 5.1. 介绍

Vue 单文件组件（又名 `*.vue` 文件，缩写为 **SFC**）是一种特殊的文件格式，它允许将 Vue 组件的 **模板**、**逻辑** 与 **样式** 封装在单个文件中。下面是 SFC 示例：

```vue
<!-- 脚本 -->
<script setup lang="ts">
import { ref } from 'vue';

const greeting = ref('Hello World!');
</script>

<!-- 模板 -->
<template>
  <p class="greeting">{{ greeting }}</p>
</template>

<!-- 样式 -->
<style scoped>
.greeting {
  color: red;
  font-weight: bold;
}
</style>
```

> 提示：上述示例中，使用 `Composition API` 风格演示 ，因为 [使用 Composition API 时更符合人体工程学的语法 >>](https://v3.cn.vuejs.org/api/sfc-script-setup) 

单文件组件由以下三种类型的顶层代码块组成：

- `<script setup>`：JavaScript 模块（脚本，处理业务逻辑）
  - 每个 `*.vue` 文件最多可同时包含一个 `<script setup>` 块
  - 该脚本会被预处理并作为组件的 `setup()` 函数使用，也就是说它会在**每个组件实例**中执行。`<script setup>` 的顶层绑定会自动暴露给模板。
- `<template>`： 组件模板（视图）
  - 每个 `*.vue` 文件最多可同时包含一个顶层 `<template>` 块。
  - 其中的内容会被提取出来并传递给 `@vue/compiler-dom`，预编译为 JavaScript 的渲染函数，并附属到导出的组件上作为其 `render` 选项。
- `<style>`：样式
  - 一个 `*.vue` 文件可以包含多个 `<style>` 标签。
  - `<style>`  标签可以通过 `scoped` 或 `module` 属性将样式封装在当前组件内。

查阅 [SFC语法规范 >>](https://v3.cn.vuejs.org/api/sfc-spec.html) 查看更多细节。

> 提示：**推荐使用单文件组件~**

### 5.2. 使用流程

单文件组件使用流程：`创建单文件组件` → `导入组件` → `注册组件` → `使用组件`

> 提示：如果你是用 `<script setup>`，则无需注册，导入之后直接使用即可。

### 5.3. 关注点分离？

一些来自传统 Web 开发背景的用户可能会担心 SFC 在同一个地方混合了不同的关注点——HTML/CSS/JS 应该分开！

要回答这个问题，我们必须同意关注点分离不等于文件类型分离。工程原理的最终目标是提高代码库的可维护性。关注点分离，当墨守成规地应用为文件类型的分离时，并不能帮助我们在日益复杂的前端应用程序的上下文中实现该目标。

在现代 UI 开发中，我们发现与其将代码库划分为三个相互交织的巨大层，不如将它们划分为松散耦合的组件并进行组合更有意义。在组件内部，它的模板、逻辑和样式是**内在耦合**的，将它们搭配起来实际上可以使组件更具**凝聚力**和**可维护性**。

# 三、组件交互

组件交互尽可能将父子组件解耦是很重要的，这保证了每个组件的代码可以在相对隔离的环境中书写和理解，从而提高了其可维护性和复用性。

在 Vue 中，父子组件的交互可以总结为：

- 父组件通过属性（`defineProps`） 向子组件传递数据；
- 子组件通过事件（`defineEmits`） 向父组件传递数据；

![](IMGS/props-events.png)

## 1. `defineProps` 

在 `<script setup>` 中通过 `defineProps`  定义子组件的 **属性**，`defineProps` 是只在 `<script setup>` 中才能使用的 **编译器宏**，他们不需要导入且会随着 `<script setup>` 处理过程一同被编译掉。

接下来我们来看一组示例：

> **子组件**

```vue
<!-- child.vue -->
<script setup lang="ts">
// -- 声明属性类型（TS）
interface IProps {
  name: string;
  age: number;
  job?: string;
}
// -- 定义属性
const props = defineProps<IProps>();
console.log(props);
</script>

<template>
  <div>{{ name }} - {{ age }} - {{ job }}</div>
</template>
```

> **父组件**

```vue
<!-- parent.vue -->
<script setup lang="ts">
// 导入子组件（无需注册）
import Child from './Child.vue';
</script>

<template>
  <!-- 使用子组件 -->
  <Child name="Li-HONGYAO" :age="28" job="前端工程师" />
</template>
```

页面输出：

```
Li-HONGYAO - 28 - 前端工程师
```

**属性默认值：`withDefaults`**

使用 `defineProps` 定义属性时无法设置默认值，为了解决这个问题，提供了 `withDefaults` 编译器宏：

```typescript
const props = withDefaults(defineProps<IProps>(), {
  name: 'Muzili',
  age: 18,
  job: '未知',
});
```

## 2. `defineEmits` 

在 `<script setup>` 中通过 `defineEmits`  定义子组件的 **事件**，`defineEmits` 是只在 `<script setup>` 中才能使用的 **编译器宏**，他们不需要导入且会随着 `<script setup>` 处理过程一同被编译掉。

1）首先，我们在 **子组件** 中定义事件：

```
const emit = defineEmits<{
    (e: 'change', id: number):void;
    (e: 'update', value: string):void;
}>();
```

上述示例中，`e` 对应事件名称，该名称可自行定义，`id` 和 `value` 表示触发时间传递的参数。

2）在 **子组件** 模板中触发事件：

```vue
<button type="button" @click="emit('change', 1)">触发[change]事件</button>
<button type="button" @click="emit('update', 'Hello')">触发[update]事件</button>
```

3）在 **父组件** 中接收事件

```vue
<script setup lang="ts">
// -- 引入子组件
import Child from './Child.vue';

// -- 监听子组件[change]事件
const onChange = (id: number) => {
  console.log(id);
};
// -- 监听子组件[update]事件
const onUpdate = (value: string) => {
  console.log(value);
};
</script>

<template>
  <Child name="Li-HONGYAO" :age="28" @change="onChange" @update="onUpdate" />
</template>
```

## 3. `v-mode`

默认情况下，组件上的 `v-model` 使用 `modelValue` 作为 prop 和 `update:modelValue` 作为事件。

当需要使用多个 `v-model` 或者说你想要实现子组件某个特定属性的 `v-model` 时，比如 `count` 属性，我们可以这样做，这里以简单封装一个 `Counter` 组件为例：

> **子组件：`src/components/Counter.vue`**

```vue
<script setup lang="ts">
interface IProps {
  min?: number;
  max?: number;
  count?: number;
}
const props = withDefaults(defineProps<IProps>(), {
  min: 1,
  max: 5,
  count: 1,
});

const emit = defineEmits<{
  (e: 'update:count', count: number): void;
}>();

// events
const plus = () => {
  const { count, max } = props;
  emit('update:count', count + 1 > max ? max : count + 1);
};
const minus = () => {
  const { count, min } = props;
  emit('update:count', count - 1 < min ? min : count - 1);
};
</script>

<template>

  <div class="wrap">
    <span>子组件：</span>
    <button type="button" @click="minus">减</button>
    <div class="v">{{ count }}</div>
    <button type="button" @click="plus">加</button>
  </div>
</template>

<style scoped>
.wrap {
  display: flex;
  justify-content: flex-start;
  align-items: center;
}
button {
  width: 30px;
  height: 30px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
}
.v {
  text-align: center;
  width: 50px;
  font-weight: bold;
}
</style>

```

> **父组件：`src/App.vue`**

```vue
<script setup lang="ts">
import { ref } from 'vue';
import Counter from './components/Counter.vue';
const count = ref(1);
</script>

<template>
  <Counter v-model:count="count" />
  <p>父组件：商品数量 → {{ count }}</p>
</template>
```

> **演示效果**：

![](./IMGS/v-model_update.gif)



# 四、插槽

Vue 实现了一套内容分发的 API，这套 API 基于当前的 [Web Components 规范草案](https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md)，将 `<slot>` 元素作为承载分发内容的出口。

## 1、插槽内容

```vue
<template>
    <a :href="url">
        <!-- 接收插槽内容 -->
        <slot></slot>
    </a>
</template>

<script>
export default {
    name: "navigation-link",
    data() {
        return {}
    },
    props: ["url"]
}
</script>
<style scoped></style>
```

```html
<navigation-link url="/login">前往登录</navigation-link>
<navigation-link url="/register">前往注册</navigation-link>
```

渲染效果：

```html
<a href="/login">前往登录</a>
<a href="/register">前往注册</a>
```

提示：插槽样式在子父组件中都可以设置，所以在命名class时一定要注意。

## 2、编译作用域

当你想在一个插槽中使用数据时，例如：

```html
<nav-link url="/profile">
  Logged in as {{ user.name }}
</nav-link>
```

该插槽跟当前模板的其它地方一样可以访问相同的实例属性 (也就是相同的“作用域”)，而**不能**访问 \<nav-link>  的作用域。例如  `url`  是访问不到的：

```html
<nav-link url="/profile">
  Clicking here will send you to: {{ url }}
</nav-link>
```

这里的 `url` 会是 undefined，因为 "/profile" 是传递给 \<nav-link> 的而不是
在 \<nav-link> 组件内部定义的。

> 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。

## 3、后备内容

```html
<template>
    <a :href="url">
        <!-- 接收插槽内容 -->
        <slot>默认内容</slot>
    </a>
</template>
```

```html
<navigation-link url="/orders"></navigation-link>
```

渲染效果：

```html
<a href="/orders">默认内容</a>
```

## 3、具名插槽

有时我们需要多个插槽，但是插槽内容会重复，如下所示：

```html
<template>
    <div class="box">
        <slot></slot>
        <hr />
        <slot></slot>
    </div>
</template>

<script>
export default {
    name: "box",
}
</script>
<style scoped></style>
```



```html
<Box>
  <h3>李鸿耀</h3>
  <p>前端开发工程师</p>
</Box>
```

运行效果：

![](./IMGS/slot-2.png)

为了解决这个问题，我们可以给插槽命名，进行相应绑定。

```vue
<template>
    <div class="box">
        <slot name="name"></slot>
        <hr />
        <slot name="job"></slot>
    </div>
</template>

<script>
export default {
    name: "box",
}
</script>
```

```vue

<Box>
  <!-- 插槽1：name -->
  <template v-slot:name>
    <h3>李鸿耀</h3>
  </template>
  <!-- 插槽2：job -->
  <template v-slot:job>
    <p>前端开发工程师</p>
  </template>
</Box>
```

运行效果：

![](./IMGS/slot-1.png)

> 提示：`v-slot` 指令可以使用 `#` 替代，比如：“v-slot:job” 可以缩写为 “#job”

> 注意：切记使用 template 包裹

## 4、作用域插槽

作用域插槽是一种特殊类型的插槽，用作一个（能被传递数据的）可重用模板，来代替已经渲染好的元素。

子传父。即长什么样，怎么布局由父级决定，而数据源则由子级决定。如：

```vue
<template>
  <div class="user">
    <!-- 绑定user属性，以便在父组件中使用 -->
    <!-- 插槽 Prop -->
    <slot :user="user"></slot>
  </div>
</template>

<script>
export default {
  name: "user",
  data() {
    return {
      user: {
        title: "李鸿耀",
        des: "前端工程师"
      }
    };
  }
};
</script>
```

```vue
<User>
  <template #default="slotProps">
    {{slotProps.user.title}} - {{slotProps.user.des}}
  </template>
</User>
```

> 注意：作用域插槽不能和具名插槽混合使用。

# 五、动态组件

通过使用保留的 \<component> 元素，动态地绑定到它的 is 特性，我们让多个组件可以使用同一个挂载点，并动态切换。

```vue
<template>
  <div id="app">
    <component :is="curPage"></component>
    <button type="button" @click="curPage = 'news'">新闻</button>
    <button type="button" @click="curPage = 'mine'">个人中心</button>
  </div>
</template>

<script>
export default {
  name: "App",
  data() {
    return {
      curPage:"news"
    }
  },
  components: {
    news: {
      template: `<div class="news">
        <h1>新闻页面</h1>
      </div>`
    },
    mine: {
      template: `<div class="news">
        <h1>个人中心页面</h1>
      </div>`
    }
  }
};
</script>
```



展示效果：

![](IMGS/dynamic-compnenet.gif)

**keep-alive**

如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染，为此可以添加一个 keep-alive 指令参数。如下所示：

```vue
<keep-alive>
    <component :is="·currentPage"></component>
</keep-alive>
```

什么情况下使用缓存：如果你需要实时更新（比如网络请求/或者时间跳转）就不能使用缓存。

> 注意：这个 `<keep-alive>` 要求被切换到的组件都有自己的名字，不论是通过组件的 `name` 选项还是局部/全局注册

## 2. v3.x 之后

[3.0 参考 >>](https://blog.csdn.net/WEB_CSDN_SHARE/article/details/95480145)













